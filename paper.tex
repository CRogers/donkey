\documentclass[12pt]{article}

\usepackage[utf8]{inputenc}
\usepackage{amsthm,amssymb,amsmath,dsfont,mathrsfs,nicefrac,wasysym}
\usepackage{listings}
\let\stdsection\section
\renewcommand\section{\newpage\stdsection}

\title{Title of my paper}
\author{Thomas Dybdahl Ahle}
\date{March 9, 2013}

\begin{document}
\maketitle

\begin{abstract}
Your abstract goes here...
...
\end{abstract}

\tableofcontents

\section{Introduction}
5 pagish Donkey example to follow through. There are many reasons why it is interesting to represent information in a logical language. You can do things such as unification, resolution, and question answering.

% It is not possible
It is clear that not all sentences can be unambigiously translated from natural language to logic. A sentence like 	
\begin{quotation}
A farmer beats a donkey
\end{quotation}
Might be translated as 
\begin{equation}
\exists x ( farmer(x) \wedge \exists y ( donkey(y) \wedge beats(x,y)))
\end{equation}
Indicating that ``a farmer'' refers to some specific individual. Or we can might see it as a general rule, and translate it as
\begin{equation}
\forall x ( farmer(x) \rightarrow \exists y ( donkey(y) \wedge beats(x,y)))
\end{equation}
Indicating that every farmer has some donkey he beats. Or we could even read it as
\begin{equation}
\exists y ( donkey(y) \wedge \forall x ( farmer(x) \rightarrow beats(x,y)))
\end{equation}
Indicating that the poor donkey is common between all farmers.
% This seams wrong to me

In this paper we will not try to solve the above problem. (Though it could be interesting to generate multiple possibilities and perhaps use context to filter out the correct one). Instead we will try to show how some old method for doing this conversion can be enhanced with some new tools

\begin{equation}
\forall x . farmer(x) \rightarrow (\forall y . donkey(y) \wedge owns(x,y) \rightarrow beats(x,y))
\end{equation}

lksadjf lakdf jlsak dfjlask dfjlask dfjlsa kdfjasld kfjsald kfjsalkd fjslakd fjlsakd fjlkasd fjlaskd jflsak dfj

If a farmer owns a donkey he beats it
\begin{equation}
\forall x . farmer(x) \rightarrow (\forall y . donkey(y) \wedge owns(x,y) \rightarrow beats(x,y))
\end{equation}

There are a lot of problems with this representation
\begin{itemize}
  \item It is not compositional. 
  dfdf
  \item It doesn't very well follow the order of the original sentence
  \item It is just not very easy to get right
\end{itemize}

\section{Formal Stuff}
10 pagish
This subsection's content...
\subsection{DPL}
Dynamic semantics: http://plato.stanford.edu/entries/dynamic-semantics/

growth of information in time
Inspired by programming language
not philosofically, states can be anything. I don't want to get into that
isomorphic with normal logic (visser siger generalization/projection)
doen't promise to be a perfect dual of natural language, but it's closer, and has been rewarding
Dynamic semantics aims to model meaning and interpretation. You can do that without answering broader philosophical questions
takes the meaning of concepts for given
discourse representation theory, file change, update semantics, 
Hans Kamp, Veltman, Groenendijk

compoitionality. A man comes in. He sees a dog. He smiles.

Vi har brug for en logik, der ikke behøver at vide alting fra starten

direct translation not possible
`He saw the man with the telescope'
and even if we understand the syntax
`The students all attended one class'
has at least two meanings.
interpretation of discourse is influenced and guided by the common ground that exists between speaker and hearer

relation between sets of assignments
$\{\overline{PQR}, \overline{PQ}R, \overline{P}Q\overline{R}, \overline{P}QR, P\overline{QR}, P\overline{Q}R, PQ\overline{R}, PQR\}$

example

real world example

something about more information, less models
the interpretation of false

Something about kleiski combinator?

the thing about quantifiers
how they would work in a programming language
$\exists x; A$
$\exists x; x = 4$ hvis $x=4$ skal virke og reducere mængden af modeller, så må exists gøre dem alle sammen mulige

A man comes in. En fri variabel vi ikke ved noget om.
A man comes in. It's Thomas..

we take as DPL-meanings binary relations between assignments

later we will use an isomorphism and take them as functions from assignments to sets of assignments.

\begin{equation}
\phi ::= \bot \mid \top \mid \pi \mid \epsilon \mid \phi \cdot \phi \mid \lnot(\phi)
\end{equation}
\begin{equation}
\alpha [\bot] \beta :\equiv False
\end{equation}
\begin{equation}
\alpha [\top] \beta :\equiv \alpha = \beta
\end{equation}
\begin{equation}
\alpha[P(x_0, ..., xn-1)]\beta :\equiv \alpha = \beta and (\alpha x0, ..., \alpha x n-1 ) \in I(P)
\end{equation}

\subsection{The problem with disjunction}


a farmer doesn't own a horse or a donkey

Ex.farmer(x) . ~(Ey.horse(y).owns(x,y) v Ey.donkey(y).owns(x,y))
Ex.farmer(x) . ~Ey.horse(y).owns(x,y) . ~Ey.donkey(y).owns(x,y)

a farmer beats a horse or a donkey

Ex.farmer(x).(Ey.horse(y) v Ez.donkey(z)).beats(x,y) = {Nothing, Ex.farmer(x).EyJust .horse(y).beats(x,y)}

Ex.farmer(x).~((Ey.horse(y) v Ez.donkey(z)).beats(x,y)) =
Ex.farmer(x).(~Ey.horse(y).~Ez.donkey(z) v ~beats(x,y)) = {Nothing, Ex.farmer(x).~Ey.horse(y).~Ez.donkey(z)}

Ex.farmer(x).~(tall(x) v blue(x)) = Ex.famer(x).~tall(x).~blue(x)

There is a farmer who maybe has a donkey. He beats it.
Ex.farmer(x).(Ey.donkey(y) v false).beats(x,y)
With union semantics for v this would be equal to
Ex.farmer(x).Ey.donkey(y).beats(x,y)
which is stupid.
Intead with sets of relations, this would be equal to
Ex.farmer(x).Ey.donkey(y).beats(x,y) v Ex.farmer(x).false.beats(x,y)
the right side being an error? no

If a farmer is not poor he owns a donkey. He beats it.
Ex.farmer(x).~poor(x) -> Ey.donkey(y).owns(x,y).beats(x,y)

A farmer is either poor or he owns a donkey. He beats it.
Ex.farmer(x).(poor(x) v Ey.donkey(y).owns(x,y)).beats(x,y) =

(Ex v false) . f(x)
(exist x `union` false) [] = [[("x",0)],[("x",1)],[("x",2)]
[Nothing, Just [[("x",0)],[("x",1)],[("x",2)]]]


(Ex v false) = [Just [[("x",0)],[("x",1)],[("x",2)], Just []]
not (Ex v false) =

not (Ex v f(x))
= ~Ex.~f(x)

A farmer owns a horse or a donkey
Ex.farmer(x).~(~(Ey.horse(y)).~(Ey.donkey(y))).owns(x,y)   this surely doesn't work


nothing survives out of a not (or impl) it's normal. Don't worry about it

Let's just say that if some of 
maybe not (bla v bla v bla v ERROR) should be ERROR
it could also be something more involved, like ERROR(bla v bla v bla v ERROR), but let's not do that
fmap

\subsection{Monadic variants}
This might be what I call DRA underneath
In the previous subsection we saw that DPL allowed us to rewrite the donkey sentence as 

\begin{equation}
\exists x \cdot farmer(x) \cdot \exists y \cdot donkey(y) \cdot owns(x,y) \rightarrow beats(x,y)
\end{equation}

($\cdot$ binds stronger than $\rightarrow$)

But think about the slight modification to the sentence:

\begin{quotation}
A farmer owns a donkey, if he beats it
\end{quotation}

We would have to write that as

\begin{equation}
\exists x \cdot farmer(x) \cdot \exists y \cdot donkey(y) \cdot beats(x,y) \rightarrow owns(x,y)
\end{equation}

The problem here is that reorderings like this work against our sought property of linearity: of being able to add new information as we go. We cannot compose `A farmer owns a donkey' and `if he beats it' in a meaningful way.

To resque us from this problem Albert Visser suggests constructing a special e-monoid over the dynamic relational algebra. The idea is that we are going to simultaniously work on two `streams' of dpl, and switch easily between them with a special element $\Bowtie$.

Our sentence from above will then be expressible as

\begin{equation}
\Bowtie \cdot \exists x \cdot farmer(x) \cdot \exists y \cdot donkey(y) \cdot \Bowtie \cdot owns(x,y) \Bowtie \cdot beats(x,y)
\end{equation}

This is however still not quite as close to natural language as we would like. Specially 

\subsection{Dependencies}
This subsection's content...
\subsection{Montague semantic}
This subsection's content...
\subsection{Semantics via dependencies}
This subsection's content...

\section{Implementation}
8pagish
This subsubsection's content...

\subsection{My implementaiton of DPL semantics}
Maybe this should be in the formal stuff. Nah, there are two versions

Below are some direct implementation of the semantics for DPL. We use the types
\begin{lstlisting}
type Assignment = [(Ref, Val)]
type Relation = [Assignment] -> [Assignment]
\end{lstlisting}
This differs from the indirect set of types are used in the earlier formalisms:
\begin{lstlisting}
type Assignment = [(Ref, Val)]
type Relation = [Assignment] -> [Assignment] -> Bool
\end{lstlisting}
The later is very difficult to implement, since the semantics require quantification over all assignments. Like for composition.

\begin{lstlisting}
:: Relation
true = id
false = const []

predi1 :: [Val] -> Ref -> Rel
predi1 f k = filter (\as -> elem (get k as) f)

predi2 :: [(Val,Val)] -> Ref -> Ref -> Rel
predi2 f k l = filter (\as -> elem (get k as, get l as) f)

:: Relation -> Relation
neg r = filter (\as -> null (r [as]))

:: Relation -> Relation -> Relation
comp = flip (.)
impl s r = rnot (s `comp` (rnot r))
\end{lstlisting}
Then comes the most interesting one. To ``randomly reset'' a variable, we have to make sure that we have all assignments in the cross product of new values for the variable and what was there before.

Bum bum. Maybe we should just use a set, then we could overwrite variable assignments
\begin{lstlisting}
exist :: Ref -> [Val] -> Rel
exist k vs ass = [a : as | a <- news, as <- olds]
	where olds = map (filter ((/=k) . fst)) ass
	      news = [(k,v) | v <- vs]
\end{lstlisting}



\subsection{Using machine learning}
The $\bowtie$ and $\triangle$ notation makes logic look close enough to natural language that it starts looking tempting to use machine learning methods such as those used in translation to translate.

My main problem here is that such translation requires large ammounts of dualingo data. It was out of scope for my project to try create such.

\subsection{Handcoding}
This is not as bad as it sounds. It is similar to montague and what the stanfordparser does for dependencies.

\section{Perspectives}
2pagish
What I learned

\section*{Acknowledgements}
Thanks to Samson
This section's content...\cite{visser1999donkey}
the PCFG parser\cite{klein2003accurate}

\subsection{Checklist}
Things learned from courses


\bibliographystyle{plain}
\bibliography{refs}

\end{document}
